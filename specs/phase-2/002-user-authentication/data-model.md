# Data Model: User Authentication

**Feature**: User Authentication
**Branch**: `002-user-authentication`
**Date**: 2025-12-14

## Overview

This document defines the data entities, relationships, and validation rules for the user authentication system. The system uses two primary entities: Users and Sessions.

## Entity Definitions

### Entity 1: User

Represents a registered user account in the system.

**Purpose**: Store user credentials and account metadata

**Lifecycle**:
1. **Created**: When user completes signup (FR-001)
2. **Updated**: When user signs in (last_signin timestamp)
3. **Deleted**: Not implemented in Phase 2 (future enhancement)

**Attributes**:

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `id` | VARCHAR(255) | PRIMARY KEY, NOT NULL | Unique user identifier (generated by Better Auth) |
| `email` | VARCHAR(255) | UNIQUE, NOT NULL | User's email address (signin credential) |
| `password_hash` | VARCHAR(255) | NOT NULL | Bcrypt hash of user's password |
| `created_at` | TIMESTAMP | NOT NULL, DEFAULT NOW() | Account creation timestamp |
| `updated_at` | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last modification timestamp |
| `last_signin_at` | TIMESTAMP | NULLABLE | Most recent successful authentication |

**Validation Rules**:
- `email`: Must match email regex pattern `/^[^\s@]+@[^\s@]+\.[^\s@]+$/`
- `email`: Must be unique across all users (enforced by UNIQUE constraint)
- `password_hash`: Generated from password meeting requirements:
  - Minimum 8 characters
  - At least one letter [a-zA-Z]
  - At least one number [0-9]
- `id`: Generated by Better Auth (UUID format)

**Indexes**:
```sql
CREATE UNIQUE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_created_at ON users(created_at);
```

**State Transitions**:
```
[New User] --signup--> [Registered]
[Registered] --signin--> [Authenticated]
[Authenticated] --signout--> [Registered]
```

**SQLModel Definition** (Backend):
```python
from sqlmodel import Field, SQLModel
from datetime import datetime
from typing import Optional

class User(SQLModel, table=True):
    __tablename__ = "users"

    id: str = Field(primary_key=True, max_length=255)
    email: str = Field(unique=True, index=True, max_length=255)
    password_hash: str = Field(max_length=255)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
    last_signin_at: Optional[datetime] = None
```

**TypeScript Type** (Frontend):
```typescript
interface User {
  id: string;
  email: string;
  // password_hash never sent to frontend
  createdAt: string;  // ISO 8601 timestamp
  updatedAt: string;  // ISO 8601 timestamp
  lastSigninAt?: string;  // ISO 8601 timestamp
}
```

### Entity 2: Session

Represents an authenticated user session with JWT token.

**Purpose**: Track active user sessions for audit and potential revocation

**Note**: This entity is **optional** in Phase 2. JWT tokens are stateless and work without server-side session storage. Sessions table enables advanced features like:
- Session revocation (signout from all devices)
- Audit logging (who accessed when, from where)
- Suspicious activity detection

**Lifecycle**:
1. **Created**: When user signs in successfully (FR-010)
2. **Updated**: On each API request (last_activity timestamp)
3. **Deleted**: When user signs out (FR-022) or session expires (FR-017)

**Attributes**:

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `id` | VARCHAR(255) | PRIMARY KEY, NOT NULL | Unique session identifier (generated) |
| `user_id` | VARCHAR(255) | FOREIGN KEY → users.id, NOT NULL | Reference to user account |
| `token_hash` | VARCHAR(255) | NOT NULL | Hash of JWT token (for revocation) |
| `created_at` | TIMESTAMP | NOT NULL, DEFAULT NOW() | Session creation time |
| `expires_at` | TIMESTAMP | NOT NULL | Session expiration time (7 days) |
| `last_activity_at` | TIMESTAMP | NOT NULL, DEFAULT NOW() | Most recent API request |
| `user_agent` | TEXT | NULLABLE | Browser/device information |
| `ip_address` | VARCHAR(45) | NULLABLE | IP address (IPv4 or IPv6) |

**Validation Rules**:
- `expires_at`: Must be 7 days from `created_at` (FR-016)
- `last_activity_at`: If current_time - `last_activity_at` > 24 hours, session is inactive (FR-017)
- `token_hash`: SHA-256 hash of JWT token for security

**Indexes**:
```sql
CREATE INDEX idx_sessions_user_id ON sessions(user_id);
CREATE INDEX idx_sessions_expires_at ON sessions(expires_at);
CREATE INDEX idx_sessions_token_hash ON sessions(token_hash);
```

**Foreign Keys**:
```sql
ALTER TABLE sessions
  ADD CONSTRAINT fk_sessions_user_id
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE;
```

**SQLModel Definition** (Backend):
```python
from sqlmodel import Field, SQLModel
from datetime import datetime, timedelta
from typing import Optional

class Session(SQLModel, table=True):
    __tablename__ = "sessions"

    id: str = Field(primary_key=True, max_length=255)
    user_id: str = Field(foreign_key="users.id", index=True, max_length=255)
    token_hash: str = Field(index=True, max_length=255)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    expires_at: datetime = Field(
        default_factory=lambda: datetime.utcnow() + timedelta(days=7)
    )
    last_activity_at: datetime = Field(default_factory=datetime.utcnow)
    user_agent: Optional[str] = None
    ip_address: Optional[str] = Field(default=None, max_length=45)
```

## Entity Relationships

```
┌─────────────┐
│    User     │
│─────────────│
│ id (PK)     │───┐
│ email       │   │
│ password_   │   │ 1:N
│   hash      │   │ (One user can have
│ created_at  │   │  multiple sessions)
│ updated_at  │   │
│ last_signin │   │
└─────────────┘   │
                  │
                  ▼
            ┌─────────────┐
            │   Session   │
            │─────────────│
            │ id (PK)     │
            │ user_id(FK) │
            │ token_hash  │
            │ created_at  │
            │ expires_at  │
            │ last_       │
            │   activity  │
            │ user_agent  │
            │ ip_address  │
            └─────────────┘
```

**Relationship Rules**:
- One User can have zero or many Sessions
- Each Session belongs to exactly one User
- Deleting a User cascades to delete all their Sessions
- A User with no Sessions is valid (signed out on all devices)

## Derived Data

### JWT Token Payload

**Not Stored in Database**: JWT tokens are stateless and self-contained

**Structure**:
```json
{
  "sub": "user_id",           // Subject: user identifier
  "email": "user@example.com", // User email (for convenience)
  "iat": 1702512000,          // Issued At: Unix timestamp
  "exp": 1703116800           // Expires: Unix timestamp (7 days)
}
```

**Generation**:
- Created by Better Auth on successful signin
- Signed with HS256 algorithm using `BETTER_AUTH_SECRET`
- Sent to frontend in signin response
- Stored in HTTP-only cookie or localStorage

**Validation**:
- Backend verifies signature using shared secret
- Checks expiration timestamp
- Extracts user_id from `sub` claim

## Data Flow Diagrams

### Signup Flow

```
User                Frontend              Backend               Database
  │                     │                     │                     │
  │──(1) Fill form─────>│                     │                     │
  │                     │──(2) POST /signup──>│                     │
  │                     │   {email, password} │                     │
  │                     │                     │──(3) Check email───>│
  │                     │                     │<──(4) Email exists?─│
  │                     │                     │                     │
  │                     │                     │──(5) Hash password  │
  │                     │                     │──(6) INSERT user───>│
  │                     │                     │<──(7) User created──│
  │                     │                     │                     │
  │                     │                     │──(8) Generate JWT   │
  │                     │<──(9) 201 + token──│                     │
  │<──(10) Redirect────│   {user, token}     │                     │
  │     to /tasks       │                     │                     │
```

### Signin Flow

```
User                Frontend              Backend               Database
  │                     │                     │                     │
  │──(1) Fill form─────>│                     │                     │
  │                     │──(2) POST /signin──>│                     │
  │                     │   {email, password} │                     │
  │                     │                     │──(3) Find user─────>│
  │                     │                     │<──(4) User record───│
  │                     │                     │                     │
  │                     │                     │──(5) Verify password│
  │                     │                     │                     │
  │                     │                     │──(6) UPDATE last───>│
  │                     │                     │     signin_at       │
  │                     │                     │                     │
  │                     │                     │──(7) Generate JWT   │
  │                     │<──(8) 200 + token──│                     │
  │<──(9) Redirect────│   {user, token}     │                     │
  │     to /tasks       │                     │                     │
```

### Session Validation Flow

```
User                Frontend              Backend               Database
  │                     │                     │                     │
  │──(1) Navigate to───>│                     │                     │
  │     /tasks          │                     │                     │
  │                     │──(2) GET /tasks────>│                     │
  │                     │   Authorization:    │                     │
  │                     │   Bearer <token>    │                     │
  │                     │                     │──(3) Verify JWT     │
  │                     │                     │     signature       │
  │                     │                     │                     │
  │                     │                     │──(4) Extract user_id│
  │                     │                     │                     │
  │                     │                     │──(5) Query tasks───>│
  │                     │                     │   WHERE user_id=?   │
  │                     │                     │<──(6) Tasks────────│
  │                     │<──(7) 200 + tasks──│                     │
  │<──(8) Display tasks│                     │                     │
```

## Database Schema SQL

### PostgreSQL Schema

```sql
-- Users table (managed by Better Auth)
CREATE TABLE users (
    id VARCHAR(255) PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
    last_signin_at TIMESTAMP
);

-- Indexes for users
CREATE UNIQUE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_created_at ON users(created_at);

-- Sessions table (optional for Phase 2)
CREATE TABLE sessions (
    id VARCHAR(255) PRIMARY KEY,
    user_id VARCHAR(255) NOT NULL,
    token_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    expires_at TIMESTAMP NOT NULL,
    last_activity_at TIMESTAMP NOT NULL DEFAULT NOW(),
    user_agent TEXT,
    ip_address VARCHAR(45),
    CONSTRAINT fk_sessions_user_id
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Indexes for sessions
CREATE INDEX idx_sessions_user_id ON sessions(user_id);
CREATE INDEX idx_sessions_expires_at ON sessions(expires_at);
CREATE INDEX idx_sessions_token_hash ON sessions(token_hash);

-- Trigger to update updated_at on users
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

## Validation Logic

### Email Validation

```python
import re

EMAIL_REGEX = r'^[^\s@]+@[^\s@]+\.[^\s@]+$'

def validate_email(email: str) -> bool:
    """Validate email format"""
    if not email or len(email) > 255:
        return False
    return bool(re.match(EMAIL_REGEX, email))
```

```typescript
const EMAIL_REGEX = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

function validateEmail(email: string): boolean {
  if (!email || email.length > 255) return false;
  return EMAIL_REGEX.test(email);
}
```

### Password Validation

```python
def validate_password(password: str) -> tuple[bool, list[str]]:
    """
    Validate password meets requirements (FR-003)
    Returns (is_valid, errors)
    """
    errors = []

    if len(password) < 8:
        errors.append("Password must be at least 8 characters")

    if not re.search(r'[a-zA-Z]', password):
        errors.append("Password must contain at least one letter")

    if not re.search(r'[0-9]', password):
        errors.append("Password must contain at least one number")

    return (len(errors) == 0, errors)
```

```typescript
function validatePassword(password: string): { valid: boolean; errors: string[] } {
  const errors: string[] = [];

  if (password.length < 8) {
    errors.push("Password must be at least 8 characters");
  }

  if (!/[a-zA-Z]/.test(password)) {
    errors.push("Password must contain at least one letter");
  }

  if (!/[0-9]/.test(password)) {
    errors.push("Password must contain at least one number");
  }

  return { valid: errors.length === 0, errors };
}
```

## Data Migration Strategy

### Phase 2 Initial Setup

**Step 1**: Better Auth automatically creates users table on first run

**Step 2**: Run custom migration for sessions table (if implemented)

```python
# backend/migrations/001_create_sessions.py
from sqlmodel import SQLModel, create_engine

def upgrade(engine):
    # Better Auth creates users table
    # We only need to create sessions if implementing
    Session.__table__.create(engine)

def downgrade(engine):
    Session.__table__.drop(engine)
```

### Future Enhancements

**Phase 3 Additions** (anticipated):
- `users.profile_picture_url` VARCHAR(500)
- `users.display_name` VARCHAR(100)
- `user_preferences` table for settings

**Migration Strategy**:
- Use Alembic for schema versioning
- All migrations must be reversible
- Test migrations in development before production
- Backup database before major schema changes

## Data Retention Policy

**Users**:
- Retained indefinitely unless user requests deletion
- No automatic cleanup

**Sessions** (if implemented):
- Expired sessions deleted after 30 days
- Cleanup job runs daily

```python
# Cleanup expired sessions
DELETE FROM sessions
WHERE expires_at < NOW() - INTERVAL '30 days';
```

## Security Considerations

**Password Storage**:
- NEVER store plaintext passwords
- Use bcrypt with salt (handled by Better Auth)
- Minimum cost factor: 12

**Token Storage**:
- Store `token_hash` in sessions table, not actual JWT
- Hash tokens with SHA-256 before storage

**Data Exposure**:
- Never return `password_hash` in API responses
- Never return `token_hash` in API responses
- Only return user `id`, `email`, and timestamps

**Database Access**:
- Use parameterized queries (SQLModel handles this)
- Principle of least privilege for database users
- Application user: SELECT, INSERT, UPDATE, DELETE only
- No CREATE/DROP/ALTER permissions for application

## Testing Data

### Test Users (Development Only)

```python
# backend/tests/fixtures/users.py
TEST_USERS = [
    {
        "email": "test@example.com",
        "password": "Test1234",  # Meets requirements
        "id": "test-user-001"
    },
    {
        "email": "admin@example.com",
        "password": "Admin5678",
        "id": "test-user-002"
    }
]
```

**Test Data Rules**:
- Never use test data in production
- Clear test database between test runs
- Use factory pattern for test data generation
